// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_addons_tile_FlxTileAnimation
#include <flixel/addons/tile/FlxTileAnimation.h>
#endif
#ifndef INCLUDED_flixel_addons_tile_FlxTileSpecial
#include <flixel/addons/tile/FlxTileSpecial.h>
#endif
#ifndef INCLUDED_flixel_addons_tile_FlxTilemapExt
#include <flixel/addons/tile/FlxTilemapExt.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxBaseTilemap
#include <flixel/tile/FlxBaseTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTile
#include <flixel/tile/FlxTile.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemap
#include <flixel/tile/FlxTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemapBuffer
#include <flixel/tile/FlxTilemapBuffer.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BlendMode
#include <openfl/_legacy/display/BlendMode.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Matrix
#include <openfl/_legacy/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Point
#include <openfl/_legacy/geom/Point.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_32_new,"flixel.addons.tile.FlxTilemapExt","new",0xf39da2c0,"flixel.addons.tile.FlxTilemapExt.new","flixel/addons/tile/FlxTilemapExt.hx",32,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_53_destroy,"flixel.addons.tile.FlxTilemapExt","destroy",0x5c98af5a,"flixel.addons.tile.FlxTilemapExt.destroy","flixel/addons/tile/FlxTilemapExt.hx",53,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_73_update,"flixel.addons.tile.FlxTilemapExt","update",0x159f6fa9,"flixel.addons.tile.FlxTilemapExt.update","flixel/addons/tile/FlxTilemapExt.hx",73,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_101_drawTilemap,"flixel.addons.tile.FlxTilemapExt","drawTilemap",0x95ca66ea,"flixel.addons.tile.FlxTilemapExt.drawTilemap","flixel/addons/tile/FlxTilemapExt.hx",101,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_262_setSpecialTiles,"flixel.addons.tile.FlxTilemapExt","setSpecialTiles",0xceebf9ae,"flixel.addons.tile.FlxTilemapExt.setSpecialTiles","flixel/addons/tile/FlxTilemapExt.hx",262,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_310_overlapsWithCallback,"flixel.addons.tile.FlxTilemapExt","overlapsWithCallback",0x527644b7,"flixel.addons.tile.FlxTilemapExt.overlapsWithCallback","flixel/addons/tile/FlxTilemapExt.hx",310,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_410_setSlopes,"flixel.addons.tile.FlxTilemapExt","setSlopes",0x172c788a,"flixel.addons.tile.FlxTilemapExt.setSlopes","flixel/addons/tile/FlxTilemapExt.hx",410,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_438_setGentle,"flixel.addons.tile.FlxTilemapExt","setGentle",0x426fecff,"flixel.addons.tile.FlxTilemapExt.setGentle","flixel/addons/tile/FlxTilemapExt.hx",438,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_461_setSteep,"flixel.addons.tile.FlxTilemapExt","setSteep",0x6a626cad,"flixel.addons.tile.FlxTilemapExt.setSteep","flixel/addons/tile/FlxTilemapExt.hx",461,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_485_checkThickGentle,"flixel.addons.tile.FlxTilemapExt","checkThickGentle",0x33400952,"flixel.addons.tile.FlxTilemapExt.checkThickGentle","flixel/addons/tile/FlxTilemapExt.hx",485,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_490_checkThinGentle,"flixel.addons.tile.FlxTilemapExt","checkThinGentle",0xc0dd29de,"flixel.addons.tile.FlxTilemapExt.checkThinGentle","flixel/addons/tile/FlxTilemapExt.hx",490,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_495_checkThickSteep,"flixel.addons.tile.FlxTilemapExt","checkThickSteep",0x02ff7bba,"flixel.addons.tile.FlxTilemapExt.checkThickSteep","flixel/addons/tile/FlxTilemapExt.hx",495,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_500_checkThinSteep,"flixel.addons.tile.FlxTilemapExt","checkThinSteep",0x3870b0ae,"flixel.addons.tile.FlxTilemapExt.checkThinSteep","flixel/addons/tile/FlxTilemapExt.hx",500,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_509_fixSlopePoint,"flixel.addons.tile.FlxTilemapExt","fixSlopePoint",0x4a6df7ba,"flixel.addons.tile.FlxTilemapExt.fixSlopePoint","flixel/addons/tile/FlxTilemapExt.hx",509,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_521_onCollideFloorSlope,"flixel.addons.tile.FlxTilemapExt","onCollideFloorSlope",0xd997f31e,"flixel.addons.tile.FlxTilemapExt.onCollideFloorSlope","flixel/addons/tile/FlxTilemapExt.hx",521,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_544_onCollideCeilSlope,"flixel.addons.tile.FlxTilemapExt","onCollideCeilSlope",0x2272f167,"flixel.addons.tile.FlxTilemapExt.onCollideCeilSlope","flixel/addons/tile/FlxTilemapExt.hx",544,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_567_solveCollisionSlopeNorthwest,"flixel.addons.tile.FlxTilemapExt","solveCollisionSlopeNorthwest",0x6b73d6bc,"flixel.addons.tile.FlxTilemapExt.solveCollisionSlopeNorthwest","flixel/addons/tile/FlxTilemapExt.hx",567,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_620_solveCollisionSlopeNortheast,"flixel.addons.tile.FlxTilemapExt","solveCollisionSlopeNortheast",0x5f8af68a,"flixel.addons.tile.FlxTilemapExt.solveCollisionSlopeNortheast","flixel/addons/tile/FlxTilemapExt.hx",620,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_673_solveCollisionSlopeSouthwest,"flixel.addons.tile.FlxTilemapExt","solveCollisionSlopeSouthwest",0x06eb4804,"flixel.addons.tile.FlxTilemapExt.solveCollisionSlopeSouthwest","flixel/addons/tile/FlxTilemapExt.hx",673,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_726_solveCollisionSlopeSoutheast,"flixel.addons.tile.FlxTilemapExt","solveCollisionSlopeSoutheast",0xfb0267d2,"flixel.addons.tile.FlxTilemapExt.solveCollisionSlopeSoutheast","flixel/addons/tile/FlxTilemapExt.hx",726,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_777_setSlopeProperties,"flixel.addons.tile.FlxTilemapExt","setSlopeProperties",0x29f54d1c,"flixel.addons.tile.FlxTilemapExt.setSlopeProperties","flixel/addons/tile/FlxTilemapExt.hx",777,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_804_checkArrays,"flixel.addons.tile.FlxTilemapExt","checkArrays",0xa0f57e02,"flixel.addons.tile.FlxTilemapExt.checkArrays","flixel/addons/tile/FlxTilemapExt.hx",804,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_808_set_frames,"flixel.addons.tile.FlxTilemapExt","set_frames",0x6ce9f783,"flixel.addons.tile.FlxTilemapExt.set_frames","flixel/addons/tile/FlxTilemapExt.hx",808,0x29266091)
namespace flixel{
namespace addons{
namespace tile{

void FlxTilemapExt_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_32_new)
HXLINE(  47)		this->_slopeThinSteep = ::Array_obj< int >::__new(0);
HXLINE(  46)		this->_slopeThickSteep = ::Array_obj< int >::__new(0);
HXLINE(  45)		this->_slopeThinGentle = ::Array_obj< int >::__new(0);
HXLINE(  44)		this->_slopeThickGentle = ::Array_obj< int >::__new(0);
HXLINE(  42)		this->_slopeSoutheast = ::Array_obj< int >::__new(0);
HXLINE(  41)		this->_slopeSouthwest = ::Array_obj< int >::__new(0);
HXLINE(  40)		this->_slopeNortheast = ::Array_obj< int >::__new(0);
HXLINE(  39)		this->_slopeNorthwest = ::Array_obj< int >::__new(0);
HXLINE(  37)		 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN(  37)		point->_inPool = false;
HXDLIN(  37)		this->_objPoint = point;
HXLINE(  36)		 ::flixel::math::FlxPoint point1 = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN(  36)		point1->_inPool = false;
HXDLIN(  36)		this->_slopePoint = point1;
HXLINE(  35)		this->_snapping = (int)2;
HXLINE(  32)		super::__construct();
            	}

Dynamic FlxTilemapExt_obj::__CreateEmpty() { return new FlxTilemapExt_obj; }

void *FlxTilemapExt_obj::_hx_vtable = 0;

Dynamic FlxTilemapExt_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxTilemapExt_obj > _hx_result = new FlxTilemapExt_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxTilemapExt_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x3cc13aa8) {
		if (inClassId<=(int)0x2e105115) {
			if (inClassId<=(int)0x25a685e0) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x25a685e0;
			} else {
				return inClassId==(int)0x2e105115;
			}
		} else {
			return inClassId==(int)0x3cc13aa8;
		}
	} else {
		return inClassId==(int)0x725f80f5 || inClassId==(int)0x75a66d6a;
	}
}

void FlxTilemapExt_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_53_destroy)
HXLINE(  54)		this->_slopePoint = ( ( ::flixel::math::FlxPoint)(::flixel::util::FlxDestroyUtil_obj::put(this->_slopePoint)) );
HXLINE(  55)		this->_objPoint = ( ( ::flixel::math::FlxPoint)(::flixel::util::FlxDestroyUtil_obj::put(this->_objPoint)) );
HXLINE(  57)		this->_slopeNorthwest = null();
HXLINE(  58)		this->_slopeNortheast = null();
HXLINE(  59)		this->_slopeSouthwest = null();
HXLINE(  60)		this->_slopeSoutheast = null();
HXLINE(  62)		this->_slopeThickGentle = null();
HXLINE(  63)		this->_slopeThinGentle = null();
HXLINE(  64)		this->_slopeThickSteep = null();
HXLINE(  65)		this->_slopeThinSteep = null();
HXLINE(  67)		this->super::destroy();
HXLINE(  69)		this->_specialTiles = ::flixel::util::FlxDestroyUtil_obj::destroyArray(this->_specialTiles);
            	}


void FlxTilemapExt_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_73_update)
HXLINE(  74)		this->super::update(elapsed);
HXLINE(  75)		bool dirty = false;
HXLINE(  77)		bool _hx_tmp;
HXDLIN(  77)		if (hx::IsNotNull( this->_specialTiles )) {
HXLINE(  77)			_hx_tmp = (this->_specialTiles->length > (int)0);
            		}
            		else {
HXLINE(  77)			_hx_tmp = false;
            		}
HXDLIN(  77)		if (_hx_tmp) {
HXLINE(  79)			int _g = (int)0;
HXDLIN(  79)			::Array< ::Dynamic> _g1 = this->_specialTiles;
HXDLIN(  79)			while((_g < _g1->length)){
HXLINE(  79)				 ::flixel::addons::tile::FlxTileSpecial tile = _g1->__get(_g).StaticCast<  ::flixel::addons::tile::FlxTileSpecial >();
HXDLIN(  79)				_g = (_g + (int)1);
HXLINE(  81)				bool _hx_tmp1;
HXDLIN(  81)				if (hx::IsNotNull( tile )) {
HXLINE(  81)					_hx_tmp1 = hx::IsNotNull( tile->animation );
            				}
            				else {
HXLINE(  81)					_hx_tmp1 = false;
            				}
HXDLIN(  81)				if (_hx_tmp1) {
HXLINE(  83)					tile->update(elapsed);
HXLINE(  84)					if (!(dirty)) {
HXLINE(  84)						dirty = tile->dirty;
            					}
            					else {
HXLINE(  84)						dirty = true;
            					}
            				}
            			}
            		}
HXLINE(  89)		if (dirty) {
HXLINE(  90)			this->setDirty(true);
            		}
            	}


void FlxTilemapExt_obj::drawTilemap( ::flixel::tile::FlxTilemapBuffer Buffer, ::flixel::FlxCamera Camera){
            	HX_GC_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_101_drawTilemap)
HXLINE( 102)		bool isColored;
HXDLIN( 102)		if ((this->alpha == (int)1)) {
HXLINE( 102)			isColored = (this->color != (int)16777215);
            		}
            		else {
HXLINE( 102)			isColored = true;
            		}
HXLINE( 104)		Float drawX = (int)0;
HXLINE( 105)		Float drawY = (int)0;
HXLINE( 106)		Float scaledWidth = this->_tileWidth;
HXLINE( 107)		Float scaledHeight = this->_tileHeight;
HXLINE( 109)		 ::flixel::math::FlxMatrix _tileTransformMatrix = null();
HXLINE( 110)		 ::flixel::math::FlxMatrix matrixToUse;
HXLINE( 112)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 114)			Buffer->fill(null());
            		}
            		else {
HXLINE( 118)			{
HXLINE( 118)				 ::flixel::math::FlxPoint _this = this->getScreenPosition(this->_point,Camera);
HXDLIN( 118)				 ::openfl::_legacy::geom::Point FlashPoint = this->_helperPoint;
HXDLIN( 118)				if (hx::IsNull( FlashPoint )) {
HXLINE( 118)					FlashPoint =  ::openfl::_legacy::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            				}
HXDLIN( 118)				FlashPoint->x = _this->x;
HXDLIN( 118)				FlashPoint->y = _this->y;
            			}
HXLINE( 120)			Float _hx_tmp;
HXDLIN( 120)			if (this->isPixelPerfectRender(Camera)) {
HXLINE( 120)				_hx_tmp = ::Math_obj::floor(this->_helperPoint->x);
            			}
            			else {
HXLINE( 120)				_hx_tmp = this->_helperPoint->x;
            			}
HXDLIN( 120)			this->_helperPoint->x = _hx_tmp;
HXLINE( 121)			Float _hx_tmp1;
HXDLIN( 121)			if (this->isPixelPerfectRender(Camera)) {
HXLINE( 121)				_hx_tmp1 = ::Math_obj::floor(this->_helperPoint->y);
            			}
            			else {
HXLINE( 121)				_hx_tmp1 = this->_helperPoint->y;
            			}
HXDLIN( 121)			this->_helperPoint->y = _hx_tmp1;
            		}
HXLINE( 125)		 ::flixel::math::FlxPoint _hx_tmp2 = this->_point;
HXDLIN( 125)		_hx_tmp2->set_x(((((Camera->scroll->x * this->scrollFactor->x) - this->x) - this->offset->x) + Camera->viewOffsetX));
HXLINE( 126)		 ::flixel::math::FlxPoint _hx_tmp3 = this->_point;
HXDLIN( 126)		_hx_tmp3->set_y(((((Camera->scroll->y * this->scrollFactor->y) - this->y) - this->offset->y) + Camera->viewOffsetY));
HXLINE( 128)		int screenXInTiles = ::Math_obj::floor(((Float)this->_point->x / (Float)this->_tileWidth));
HXLINE( 129)		int screenYInTiles = ::Math_obj::floor(((Float)this->_point->y / (Float)this->_tileHeight));
HXLINE( 130)		int screenRows = Buffer->rows;
HXLINE( 131)		int screenColumns = Buffer->columns;
HXLINE( 134)		 ::Dynamic Max = (this->widthInTiles - screenColumns);
HXDLIN( 134)		Float lowerBound;
HXDLIN( 134)		if ((screenXInTiles < (int)0)) {
HXLINE( 134)			lowerBound = (int)0;
            		}
            		else {
HXLINE( 134)			lowerBound = screenXInTiles;
            		}
HXDLIN( 134)		Float screenXInTiles1;
HXDLIN( 134)		bool screenXInTiles2;
HXDLIN( 134)		if (hx::IsNotNull( Max )) {
HXLINE( 134)			screenXInTiles2 = hx::IsGreater( lowerBound,Max );
            		}
            		else {
HXLINE( 134)			screenXInTiles2 = false;
            		}
HXDLIN( 134)		if (screenXInTiles2) {
HXLINE( 134)			screenXInTiles1 = Max;
            		}
            		else {
HXLINE( 134)			screenXInTiles1 = lowerBound;
            		}
HXDLIN( 134)		screenXInTiles = ::Std_obj::_hx_int(screenXInTiles1);
HXLINE( 135)		 ::Dynamic Max1 = (this->heightInTiles - screenRows);
HXDLIN( 135)		Float lowerBound1;
HXDLIN( 135)		if ((screenYInTiles < (int)0)) {
HXLINE( 135)			lowerBound1 = (int)0;
            		}
            		else {
HXLINE( 135)			lowerBound1 = screenYInTiles;
            		}
HXDLIN( 135)		Float screenYInTiles1;
HXDLIN( 135)		bool screenYInTiles2;
HXDLIN( 135)		if (hx::IsNotNull( Max1 )) {
HXLINE( 135)			screenYInTiles2 = hx::IsGreater( lowerBound1,Max1 );
            		}
            		else {
HXLINE( 135)			screenYInTiles2 = false;
            		}
HXDLIN( 135)		if (screenYInTiles2) {
HXLINE( 135)			screenYInTiles1 = Max1;
            		}
            		else {
HXLINE( 135)			screenYInTiles1 = lowerBound1;
            		}
HXDLIN( 135)		screenYInTiles = ::Std_obj::_hx_int(screenYInTiles1);
HXLINE( 137)		int rowIndex = ((screenYInTiles * this->widthInTiles) + screenXInTiles);
HXLINE( 138)		this->_flashPoint->y = (int)0;
HXLINE( 139)		int columnIndex;
HXLINE( 140)		 ::flixel::tile::FlxTile tile;
HXLINE( 141)		 ::flixel::graphics::frames::FlxFrame frame;
HXLINE( 142)		 ::flixel::addons::tile::FlxTileSpecial special;
HXLINE( 148)		bool isSpecial = false;
HXLINE( 150)		{
HXLINE( 150)			int _g1 = (int)0;
HXDLIN( 150)			int _g = screenRows;
HXDLIN( 150)			while((_g1 < _g)){
HXLINE( 150)				_g1 = (_g1 + (int)1);
HXDLIN( 150)				int row = (_g1 - (int)1);
HXLINE( 152)				columnIndex = rowIndex;
HXLINE( 153)				this->_flashPoint->x = (int)0;
HXLINE( 155)				{
HXLINE( 155)					int _g3 = (int)0;
HXDLIN( 155)					int _g2 = screenColumns;
HXDLIN( 155)					while((_g3 < _g2)){
HXLINE( 155)						_g3 = (_g3 + (int)1);
HXDLIN( 155)						int column = (_g3 - (int)1);
HXLINE( 157)						::Array< ::Dynamic> tile1 = this->_tileObjects;
HXDLIN( 157)						tile = tile1->__get(this->_data->__get(columnIndex)).StaticCast<  ::flixel::tile::FlxTile >();
HXLINE( 158)						special = null();
HXLINE( 159)						isSpecial = false;
HXLINE( 161)						bool _hx_tmp4;
HXDLIN( 161)						if (hx::IsNotNull( this->_specialTiles )) {
HXLINE( 161)							_hx_tmp4 = hx::IsNotNull( this->_specialTiles->__get(columnIndex).StaticCast<  ::flixel::addons::tile::FlxTileSpecial >() );
            						}
            						else {
HXLINE( 161)							_hx_tmp4 = false;
            						}
HXDLIN( 161)						if (_hx_tmp4) {
HXLINE( 163)							special = this->_specialTiles->__get(columnIndex).StaticCast<  ::flixel::addons::tile::FlxTileSpecial >();
HXLINE( 164)							bool isSpecial1;
HXDLIN( 164)							bool isSpecial2;
HXDLIN( 164)							if (!(special->flipX)) {
HXLINE( 164)								isSpecial2 = special->flipY;
            							}
            							else {
HXLINE( 164)								isSpecial2 = true;
            							}
HXDLIN( 164)							if (!(isSpecial2)) {
HXLINE( 164)								isSpecial1 = (special->rotate != (int)0);
            							}
            							else {
HXLINE( 164)								isSpecial1 = true;
            							}
HXDLIN( 164)							if (!(isSpecial1)) {
HXLINE( 164)								isSpecial = hx::IsNotNull( special->animation );
            							}
            							else {
HXLINE( 164)								isSpecial = true;
            							}
            						}
HXLINE( 167)						if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 169)							if (isSpecial) {
HXLINE( 171)								special->paint(Buffer->pixels,this->_flashPoint);
HXLINE( 172)								bool _hx_tmp5;
HXDLIN( 172)								if (!(special->dirty)) {
HXLINE( 172)									_hx_tmp5 = Buffer->dirty;
            								}
            								else {
HXLINE( 172)									_hx_tmp5 = true;
            								}
HXDLIN( 172)								Buffer->dirty = _hx_tmp5;
            							}
            							else {
HXLINE( 174)								bool _hx_tmp6;
HXDLIN( 174)								bool _hx_tmp7;
HXDLIN( 174)								if (hx::IsNotNull( tile )) {
HXLINE( 174)									_hx_tmp7 = tile->visible;
            								}
            								else {
HXLINE( 174)									_hx_tmp7 = false;
            								}
HXDLIN( 174)								if (_hx_tmp7) {
HXLINE( 174)									_hx_tmp6 = (tile->frame->type != (int)2);
            								}
            								else {
HXLINE( 174)									_hx_tmp6 = false;
            								}
HXDLIN( 174)								if (_hx_tmp6) {
HXLINE( 176)									tile->frame->paint(Buffer->pixels,this->_flashPoint,true,null());
            								}
            							}
            						}
            						else {
HXLINE( 207)							if (isSpecial) {
HXLINE( 207)								frame = special->currFrame;
            							}
            							else {
HXLINE( 207)								frame = tile->frame;
            							}
HXLINE( 209)							if (hx::IsNotNull( frame )) {
HXLINE( 211)								Float drawX1 = this->_helperPoint->x;
HXDLIN( 211)								drawX = (drawX1 + (hx::Mod(columnIndex,this->widthInTiles) * scaledWidth));
HXLINE( 212)								Float drawY1 = this->_helperPoint->y;
HXDLIN( 212)								drawY = (drawY1 + (::Math_obj::floor(((Float)columnIndex / (Float)this->widthInTiles)) * scaledHeight));
HXLINE( 214)								if (isSpecial) {
HXLINE( 216)									_tileTransformMatrix = special->getMatrix();
HXLINE( 217)									matrixToUse = _tileTransformMatrix;
            								}
            								else {
HXLINE( 221)									frame->prepareMatrix(this->_matrix,null(),null(),null());
HXLINE( 222)									matrixToUse = this->_matrix;
            								}
HXLINE( 225)								matrixToUse->translate(drawX,drawY);
HXLINE( 226)								Camera->drawPixels(frame,null(),matrixToUse,this->colorTransform,this->blend,null(),null());
            							}
            						}
HXLINE( 230)						if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 232)							 ::openfl::_legacy::geom::Point _hx_tmp8 = this->_flashPoint;
HXDLIN( 232)							_hx_tmp8->x = (_hx_tmp8->x + this->_tileWidth);
            						}
HXLINE( 234)						columnIndex = (columnIndex + (int)1);
            					}
            				}
HXLINE( 237)				rowIndex = (rowIndex + this->widthInTiles);
HXLINE( 238)				if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 240)					 ::openfl::_legacy::geom::Point _hx_tmp9 = this->_flashPoint;
HXDLIN( 240)					_hx_tmp9->y = (_hx_tmp9->y + this->_tileHeight);
            				}
            			}
            		}
HXLINE( 244)		Buffer->x = (screenXInTiles * this->_tileWidth);
HXLINE( 245)		Buffer->y = (screenYInTiles * this->_tileHeight);
HXLINE( 247)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 249)			if (isColored) {
HXLINE( 250)				Buffer->colorTransform(this->colorTransform);
            			}
HXLINE( 251)			Buffer->blend = this->blend;
            		}
HXLINE( 254)		Buffer->dirty = false;
            	}


void FlxTilemapExt_obj::setSpecialTiles(::Array< ::Dynamic> tiles){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_262_setSpecialTiles)
HXLINE( 263)		this->_specialTiles = ::Array_obj< ::Dynamic>::__new();
HXLINE( 265)		 ::flixel::addons::tile::FlxTileSpecial tile;
HXLINE( 266)		{
HXLINE( 266)			int _g1 = (int)0;
HXDLIN( 266)			int _g = tiles->length;
HXDLIN( 266)			while((_g1 < _g)){
HXLINE( 266)				_g1 = (_g1 + (int)1);
HXDLIN( 266)				int i = (_g1 - (int)1);
HXLINE( 268)				tile = tiles->__get(i).StaticCast<  ::flixel::addons::tile::FlxTileSpecial >();
HXLINE( 269)				bool _hx_tmp;
HXDLIN( 269)				if (hx::IsNotNull( tile )) {
HXLINE( 269)					bool _hx_tmp1;
HXDLIN( 269)					bool _hx_tmp2;
HXDLIN( 269)					if (!(tile->flipX)) {
HXLINE( 269)						_hx_tmp2 = tile->flipY;
            					}
            					else {
HXLINE( 269)						_hx_tmp2 = true;
            					}
HXDLIN( 269)					if (!(_hx_tmp2)) {
HXLINE( 269)						_hx_tmp1 = (tile->rotate != (int)0);
            					}
            					else {
HXLINE( 269)						_hx_tmp1 = true;
            					}
HXDLIN( 269)					if (!(_hx_tmp1)) {
HXLINE( 269)						_hx_tmp = hx::IsNotNull( tile->animation );
            					}
            					else {
HXLINE( 269)						_hx_tmp = true;
            					}
            				}
            				else {
HXLINE( 269)					_hx_tmp = false;
            				}
HXDLIN( 269)				if (_hx_tmp) {
HXLINE( 271)					this->_specialTiles[i] = tile;
HXLINE( 273)					{
HXLINE( 273)						 ::flixel::addons::tile::FlxTileSpecial _g2 = tile;
HXDLIN( 273)						_g2->set_currTileId((_g2->currTileId - this->_startingIndex));
            					}
HXLINE( 274)					tile->set_frames(this->frames);
HXLINE( 276)					if (hx::IsNotNull( tile->animation )) {
HXLINE( 278)						::Array< int > animFrames = tile->animation->frames;
HXLINE( 279)						::Array< int > preparedFrames = ::Array_obj< int >::__new(0);
HXLINE( 281)						{
HXLINE( 281)							int _g3 = (int)0;
HXDLIN( 281)							int _g21 = animFrames->length;
HXDLIN( 281)							while((_g3 < _g21)){
HXLINE( 281)								_g3 = (_g3 + (int)1);
HXDLIN( 281)								int j = (_g3 - (int)1);
HXLINE( 283)								preparedFrames[j] = (animFrames->__get(j) - this->_startingIndex);
            							}
            						}
HXLINE( 286)						tile->animation->frames = preparedFrames;
            					}
            				}
            				else {
HXLINE( 291)					this->_specialTiles[i] = null();
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,setSpecialTiles,(void))

bool FlxTilemapExt_obj::overlapsWithCallback( ::flixel::FlxObject Object, ::Dynamic Callback,hx::Null< bool >  __o_FlipCallbackParams, ::flixel::math::FlxPoint Position){
bool FlipCallbackParams = __o_FlipCallbackParams.Default(false);
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_310_overlapsWithCallback)
HXLINE( 311)		bool results = false;
HXLINE( 313)		Float X = this->x;
HXLINE( 314)		Float Y = this->y;
HXLINE( 316)		if (hx::IsNotNull( Position )) {
HXLINE( 318)			X = Position->x;
HXLINE( 319)			Y = Position->y;
            		}
HXLINE( 323)		int selectionX = ::Math_obj::floor(((Float)(Object->x - X) / (Float)this->_tileWidth));
HXLINE( 324)		int selectionY = ::Math_obj::floor(((Float)(Object->y - Y) / (Float)this->_tileHeight));
HXLINE( 325)		Float selectionWidth = Object->get_width();
HXDLIN( 325)		int selectionWidth1 = ((selectionX + ::Math_obj::ceil(((Float)selectionWidth / (Float)this->_tileWidth))) + (int)1);
HXLINE( 326)		Float selectionHeight = Object->get_height();
HXDLIN( 326)		int selectionHeight1 = ((selectionY + ::Math_obj::ceil(((Float)selectionHeight / (Float)this->_tileHeight))) + (int)1);
HXLINE( 329)		if ((selectionX > (int)0)) {
HXLINE( 329)			selectionX = selectionX;
            		}
            		else {
HXLINE( 329)			selectionX = (int)0;
            		}
HXLINE( 330)		if ((selectionY > (int)0)) {
HXLINE( 330)			selectionY = selectionY;
            		}
            		else {
HXLINE( 330)			selectionY = (int)0;
            		}
HXLINE( 331)		int b = this->widthInTiles;
HXDLIN( 331)		if ((selectionWidth1 > b)) {
HXLINE( 331)			selectionWidth1 = b;
            		}
            		else {
HXLINE( 331)			selectionWidth1 = selectionWidth1;
            		}
HXLINE( 332)		int b1 = this->heightInTiles;
HXDLIN( 332)		if ((selectionHeight1 > b1)) {
HXLINE( 332)			selectionHeight1 = b1;
            		}
            		else {
HXLINE( 332)			selectionHeight1 = selectionHeight1;
            		}
HXLINE( 335)		int rowStart = (selectionY * this->widthInTiles);
HXLINE( 336)		int row = selectionY;
HXLINE( 337)		int column;
HXLINE( 338)		 ::flixel::tile::FlxTile tile;
HXLINE( 339)		bool overlapFound;
HXLINE( 340)		Float deltaX = (X - this->last->x);
HXLINE( 341)		Float deltaY = (Y - this->last->y);
HXLINE( 343)		while((row < selectionHeight1)){
HXLINE( 345)			column = selectionX;
HXLINE( 347)			while((column < selectionWidth1)){
HXLINE( 349)				overlapFound = false;
HXLINE( 350)				::Array< ::Dynamic> tile1 = this->_tileObjects;
HXDLIN( 350)				::Array< int > tile2 = this->_data;
HXDLIN( 350)				tile = tile1->__get(tile2->__get((rowStart + column))).StaticCast<  ::flixel::tile::FlxTile >();
HXLINE( 352)				if ((tile->allowCollisions != (int)0)) {
HXLINE( 354)					tile->set_x((X + (column * this->_tileWidth)));
HXLINE( 355)					tile->set_y((Y + (row * this->_tileHeight)));
HXLINE( 356)					 ::flixel::math::FlxPoint tile3 = tile->last;
HXDLIN( 356)					tile3->set_x((tile->x - deltaX));
HXLINE( 357)					 ::flixel::math::FlxPoint tile4 = tile->last;
HXDLIN( 357)					tile4->set_y((tile->y - deltaY));
HXLINE( 359)					if (hx::IsNotNull( Callback )) {
HXLINE( 361)						if (FlipCallbackParams) {
HXLINE( 363)							overlapFound = ( (bool)(Callback(Object,tile)) );
            						}
            						else {
HXLINE( 367)							overlapFound = ( (bool)(Callback(tile,Object)) );
            						}
            					}
            					else {
HXLINE( 372)						bool overlapFound1;
HXDLIN( 372)						bool overlapFound2;
HXDLIN( 372)						Float Object1 = Object->x;
HXDLIN( 372)						Float overlapFound3 = (Object1 + Object->get_width());
HXDLIN( 372)						if ((overlapFound3 > tile->x)) {
HXLINE( 372)							Float Object2 = Object->x;
HXDLIN( 372)							Float tile5 = tile->x;
HXDLIN( 372)							overlapFound2 = (Object2 < (tile5 + tile->get_width()));
            						}
            						else {
HXLINE( 372)							overlapFound2 = false;
            						}
HXDLIN( 372)						if (overlapFound2) {
HXLINE( 372)							Float Object3 = Object->y;
HXDLIN( 372)							Float overlapFound4 = (Object3 + Object->get_height());
HXDLIN( 372)							overlapFound1 = (overlapFound4 > tile->y);
            						}
            						else {
HXLINE( 372)							overlapFound1 = false;
            						}
HXDLIN( 372)						if (overlapFound1) {
HXLINE( 372)							Float Object4 = Object->y;
HXDLIN( 372)							Float tile6 = tile->y;
HXDLIN( 372)							overlapFound = (Object4 < (tile6 + tile->get_height()));
            						}
            						else {
HXLINE( 372)							overlapFound = false;
            						}
            					}
HXLINE( 376)					bool _hx_tmp;
HXDLIN( 376)					if (!(overlapFound)) {
HXLINE( 376)						if (!(overlapFound)) {
HXLINE( 376)							_hx_tmp = this->checkArrays(tile->index);
            						}
            						else {
HXLINE( 376)							_hx_tmp = false;
            						}
            					}
            					else {
HXLINE( 376)						_hx_tmp = true;
            					}
HXDLIN( 376)					if (_hx_tmp) {
HXLINE( 378)						bool _hx_tmp1;
HXDLIN( 378)						if (hx::IsNotNull( tile->callbackFunction )) {
HXLINE( 378)							if (hx::IsNotNull( tile->filter )) {
HXLINE( 378)								_hx_tmp1 = ::Std_obj::is(Object,tile->filter);
            							}
            							else {
HXLINE( 378)								_hx_tmp1 = true;
            							}
            						}
            						else {
HXLINE( 378)							_hx_tmp1 = false;
            						}
HXDLIN( 378)						if (_hx_tmp1) {
HXLINE( 380)							tile->mapIndex = (rowStart + column);
HXLINE( 381)							tile->callbackFunction(tile,Object);
            						}
HXLINE( 383)						results = true;
            					}
            				}
            				else {
HXLINE( 386)					bool _hx_tmp2;
HXDLIN( 386)					if (hx::IsNotNull( tile->callbackFunction )) {
HXLINE( 386)						if (hx::IsNotNull( tile->filter )) {
HXLINE( 386)							_hx_tmp2 = ::Std_obj::is(Object,tile->filter);
            						}
            						else {
HXLINE( 386)							_hx_tmp2 = true;
            						}
            					}
            					else {
HXLINE( 386)						_hx_tmp2 = false;
            					}
HXDLIN( 386)					if (_hx_tmp2) {
HXLINE( 388)						tile->mapIndex = (rowStart + column);
HXLINE( 389)						tile->callbackFunction(tile,Object);
            					}
            				}
HXLINE( 391)				column = (column + (int)1);
            			}
HXLINE( 394)			rowStart = (rowStart + this->widthInTiles);
HXLINE( 395)			row = (row + (int)1);
            		}
HXLINE( 398)		return results;
            	}


void FlxTilemapExt_obj::setSlopes(::Array< int > Northwest,::Array< int > Northeast,::Array< int > Southwest,::Array< int > Southeast){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_410_setSlopes)
HXLINE( 411)		if (hx::IsNotNull( Northwest )) {
HXLINE( 413)			this->_slopeNorthwest = Northwest;
            		}
HXLINE( 415)		if (hx::IsNotNull( Northeast )) {
HXLINE( 417)			this->_slopeNortheast = Northeast;
            		}
HXLINE( 419)		if (hx::IsNotNull( Southwest )) {
HXLINE( 421)			this->_slopeSouthwest = Southwest;
            		}
HXLINE( 423)		if (hx::IsNotNull( Southeast )) {
HXLINE( 425)			this->_slopeSoutheast = Southeast;
            		}
HXLINE( 428)		this->setSlopeProperties();
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxTilemapExt_obj,setSlopes,(void))

void FlxTilemapExt_obj::setGentle(::Array< int > ThickTiles,::Array< int > ThinTiles){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_438_setGentle)
HXLINE( 439)		if (hx::IsNotNull( ThickTiles )) {
HXLINE( 441)			this->_slopeThickGentle = ThickTiles;
            		}
HXLINE( 444)		if (hx::IsNotNull( ThinTiles )) {
HXLINE( 446)			this->_slopeThinGentle = ThinTiles;
HXLINE( 447)			{
HXLINE( 447)				int _g = (int)0;
HXDLIN( 447)				::Array< int > _g1 = this->_slopeThinGentle;
HXDLIN( 447)				while((_g < _g1->length)){
HXLINE( 447)					int tile = _g1->__get(_g);
HXDLIN( 447)					_g = (_g + (int)1);
HXLINE( 449)					 ::flixel::tile::FlxTile _hx_tmp = Dynamic( this->_tileObjects->__get(tile)).StaticCast<  ::flixel::tile::FlxTile >();
HXDLIN( 449)					int _hx_tmp1;
HXDLIN( 449)					bool _hx_tmp2;
HXDLIN( 449)					if ((this->_slopeSouthwest->indexOf(tile,null()) < (int)0)) {
HXLINE( 449)						_hx_tmp2 = (this->_slopeSoutheast->indexOf(tile,null()) >= (int)0);
            					}
            					else {
HXLINE( 449)						_hx_tmp2 = true;
            					}
HXDLIN( 449)					if (_hx_tmp2) {
HXLINE( 449)						_hx_tmp1 = (int)256;
            					}
            					else {
HXLINE( 449)						_hx_tmp1 = (int)4096;
            					}
HXDLIN( 449)					_hx_tmp->set_allowCollisions(_hx_tmp1);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,setGentle,(void))

void FlxTilemapExt_obj::setSteep(::Array< int > ThickTiles,::Array< int > ThinTiles){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_461_setSteep)
HXLINE( 462)		if (hx::IsNotNull( ThickTiles )) {
HXLINE( 464)			this->_slopeThickSteep = ThickTiles;
            		}
HXLINE( 467)		if (hx::IsNotNull( ThinTiles )) {
HXLINE( 469)			this->_slopeThinSteep = ThinTiles;
HXLINE( 470)			{
HXLINE( 470)				int _g = (int)0;
HXDLIN( 470)				::Array< int > _g1 = this->_slopeThinSteep;
HXDLIN( 470)				while((_g < _g1->length)){
HXLINE( 470)					int tile = _g1->__get(_g);
HXDLIN( 470)					_g = (_g + (int)1);
HXLINE( 472)					 ::flixel::tile::FlxTile _hx_tmp = Dynamic( this->_tileObjects->__get(tile)).StaticCast<  ::flixel::tile::FlxTile >();
HXDLIN( 472)					int _hx_tmp1;
HXDLIN( 472)					bool _hx_tmp2;
HXDLIN( 472)					if ((this->_slopeSouthwest->indexOf(tile,null()) < (int)0)) {
HXLINE( 472)						_hx_tmp2 = (this->_slopeNorthwest->indexOf(tile,null()) >= (int)0);
            					}
            					else {
HXLINE( 472)						_hx_tmp2 = true;
            					}
HXDLIN( 472)					if (_hx_tmp2) {
HXLINE( 472)						_hx_tmp1 = (int)16;
            					}
            					else {
HXLINE( 472)						_hx_tmp1 = (int)1;
            					}
HXDLIN( 472)					_hx_tmp->set_allowCollisions(_hx_tmp1);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,setSteep,(void))

bool FlxTilemapExt_obj::checkThickGentle(int TileIndex){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_485_checkThickGentle)
HXDLIN( 485)		return (this->_slopeThickGentle->indexOf(TileIndex,null()) >= (int)0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,checkThickGentle,return )

bool FlxTilemapExt_obj::checkThinGentle(int TileIndex){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_490_checkThinGentle)
HXDLIN( 490)		return (this->_slopeThinGentle->indexOf(TileIndex,null()) >= (int)0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,checkThinGentle,return )

bool FlxTilemapExt_obj::checkThickSteep(int TileIndex){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_495_checkThickSteep)
HXDLIN( 495)		return (this->_slopeThickSteep->indexOf(TileIndex,null()) >= (int)0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,checkThickSteep,return )

bool FlxTilemapExt_obj::checkThinSteep(int TileIndex){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_500_checkThinSteep)
HXDLIN( 500)		return (this->_slopeThinSteep->indexOf(TileIndex,null()) >= (int)0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,checkThinSteep,return )

void FlxTilemapExt_obj::fixSlopePoint( ::flixel::tile::FlxTile Slope){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_509_fixSlopePoint)
HXLINE( 510)		Float Value = this->_slopePoint->x;
HXDLIN( 510)		 ::Dynamic Min = Slope->x;
HXDLIN( 510)		 ::Dynamic Max = (Slope->x + this->_tileWidth);
HXDLIN( 510)		Float lowerBound;
HXDLIN( 510)		bool lowerBound1;
HXDLIN( 510)		if (hx::IsNotNull( Min )) {
HXLINE( 510)			lowerBound1 = hx::IsLess( Value,Min );
            		}
            		else {
HXLINE( 510)			lowerBound1 = false;
            		}
HXDLIN( 510)		if (lowerBound1) {
HXLINE( 510)			lowerBound = Min;
            		}
            		else {
HXLINE( 510)			lowerBound = Value;
            		}
HXDLIN( 510)		Float _hx_tmp;
HXDLIN( 510)		bool _hx_tmp1;
HXDLIN( 510)		if (hx::IsNotNull( Max )) {
HXLINE( 510)			_hx_tmp1 = hx::IsGreater( lowerBound,Max );
            		}
            		else {
HXLINE( 510)			_hx_tmp1 = false;
            		}
HXDLIN( 510)		if (_hx_tmp1) {
HXLINE( 510)			_hx_tmp = Max;
            		}
            		else {
HXLINE( 510)			_hx_tmp = lowerBound;
            		}
HXDLIN( 510)		this->_slopePoint->set_x(_hx_tmp);
HXLINE( 511)		Float Value1 = this->_slopePoint->y;
HXDLIN( 511)		 ::Dynamic Min1 = Slope->y;
HXDLIN( 511)		 ::Dynamic Max1 = (Slope->y + this->_tileHeight);
HXDLIN( 511)		Float lowerBound2;
HXDLIN( 511)		bool lowerBound3;
HXDLIN( 511)		if (hx::IsNotNull( Min1 )) {
HXLINE( 511)			lowerBound3 = hx::IsLess( Value1,Min1 );
            		}
            		else {
HXLINE( 511)			lowerBound3 = false;
            		}
HXDLIN( 511)		if (lowerBound3) {
HXLINE( 511)			lowerBound2 = Min1;
            		}
            		else {
HXLINE( 511)			lowerBound2 = Value1;
            		}
HXDLIN( 511)		Float _hx_tmp2;
HXDLIN( 511)		bool _hx_tmp3;
HXDLIN( 511)		if (hx::IsNotNull( Max1 )) {
HXLINE( 511)			_hx_tmp3 = hx::IsGreater( lowerBound2,Max1 );
            		}
            		else {
HXLINE( 511)			_hx_tmp3 = false;
            		}
HXDLIN( 511)		if (_hx_tmp3) {
HXLINE( 511)			_hx_tmp2 = Max1;
            		}
            		else {
HXLINE( 511)			_hx_tmp2 = lowerBound2;
            		}
HXDLIN( 511)		this->_slopePoint->set_y(_hx_tmp2);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,fixSlopePoint,(void))

void FlxTilemapExt_obj::onCollideFloorSlope( ::flixel::FlxObject Slope, ::flixel::FlxObject Object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_521_onCollideFloorSlope)
HXLINE( 523)		Object->touching = (int)4096;
HXLINE( 526)		 ::flixel::math::FlxPoint Object1 = Object->velocity;
HXDLIN( 526)		Object1->set_y(::Math_obj::min(Object->velocity->y,(int)0));
HXLINE( 529)		Float _hx_tmp = this->_slopePoint->y;
HXDLIN( 529)		Object->set_y((_hx_tmp - Object->get_height()));
HXLINE( 531)		Float Object2 = Object->y;
HXDLIN( 531)		Float Slope1 = Slope->y;
HXDLIN( 531)		if ((Object2 < (Slope1 - Object->get_height()))) {
HXLINE( 533)			Float Slope2 = Slope->y;
HXDLIN( 533)			Object->set_y((Slope2 - Object->get_height()));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,onCollideFloorSlope,(void))

void FlxTilemapExt_obj::onCollideCeilSlope( ::flixel::FlxObject Slope, ::flixel::FlxObject Object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_544_onCollideCeilSlope)
HXLINE( 546)		Object->touching = (int)256;
HXLINE( 549)		 ::flixel::math::FlxPoint Object1 = Object->velocity;
HXDLIN( 549)		Object1->set_y(::Math_obj::max(Object->velocity->y,(int)0));
HXLINE( 552)		Object->set_y(this->_slopePoint->y);
HXLINE( 554)		Float Object2 = Object->y;
HXDLIN( 554)		if ((Object2 > (Slope->y + this->_tileHeight))) {
HXLINE( 556)			Object->set_y((Slope->y + this->_tileHeight));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,onCollideCeilSlope,(void))

void FlxTilemapExt_obj::solveCollisionSlopeNorthwest( ::flixel::FlxObject Slope, ::flixel::FlxObject Object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_567_solveCollisionSlopeNorthwest)
HXLINE( 569)		 ::flixel::math::FlxPoint _hx_tmp = this->_objPoint;
HXDLIN( 569)		Float Object1 = Object->x;
HXDLIN( 569)		Float _hx_tmp1 = (Object1 + Object->get_width());
HXDLIN( 569)		_hx_tmp->set_x(::Math_obj::floor((_hx_tmp1 + this->_snapping)));
HXLINE( 570)		 ::flixel::math::FlxPoint _hx_tmp2 = this->_objPoint;
HXDLIN( 570)		Float Object2 = Object->y;
HXDLIN( 570)		_hx_tmp2->set_y(::Math_obj::floor((Object2 + Object->get_height())));
HXLINE( 574)		this->_slopePoint->set_x(this->_objPoint->x);
HXLINE( 575)		 ::flixel::math::FlxPoint _hx_tmp3 = this->_slopePoint;
HXDLIN( 575)		Float _hx_tmp4 = (Slope->y + this->_tileHeight);
HXDLIN( 575)		_hx_tmp3->set_y((_hx_tmp4 - (this->_slopePoint->x - Slope->x)));
HXLINE( 577)		int tileId = hx::TCast<  ::flixel::tile::FlxTile >::cast(Slope)->index;
HXLINE( 578)		if (this->checkThinSteep(tileId)) {
HXLINE( 580)			Float _hx_tmp5 = (this->_slopePoint->x - Slope->x);
HXDLIN( 580)			if ((_hx_tmp5 <= ((Float)this->_tileWidth / (Float)(int)2))) {
HXLINE( 582)				return;
            			}
            			else {
HXLINE( 586)				 ::flixel::math::FlxPoint _hx_tmp6 = this->_slopePoint;
HXDLIN( 586)				Float Slope1 = Slope->y;
HXDLIN( 586)				int _hx_tmp7 = this->_tileHeight;
HXDLIN( 586)				_hx_tmp6->set_y(((Slope1 + (_hx_tmp7 * ((int)2 - ((Float)((int)2 * (this->_slopePoint->x - Slope->x)) / (Float)this->_tileWidth)))) + this->_snapping));
            			}
            		}
            		else {
HXLINE( 589)			if (this->checkThickSteep(tileId)) {
HXLINE( 591)				 ::flixel::math::FlxPoint _hx_tmp8 = this->_slopePoint;
HXDLIN( 591)				Float Slope2 = Slope->y;
HXDLIN( 591)				int _hx_tmp9 = this->_tileHeight;
HXDLIN( 591)				_hx_tmp8->set_y(((Slope2 + (_hx_tmp9 * ((int)1 - ((int)2 * ((Float)(this->_slopePoint->x - Slope->x) / (Float)this->_tileWidth))))) + this->_snapping));
            			}
            			else {
HXLINE( 593)				if (this->checkThickGentle(tileId)) {
HXLINE( 595)					 ::flixel::math::FlxPoint _hx_tmp10 = this->_slopePoint;
HXDLIN( 595)					Float Slope3 = Slope->y;
HXDLIN( 595)					_hx_tmp10->set_y((Slope3 + ((Float)((this->_tileHeight - this->_slopePoint->x) + Slope->x) / (Float)(int)2)));
            				}
            				else {
HXLINE( 597)					if (this->checkThinGentle(tileId)) {
HXLINE( 599)						 ::flixel::math::FlxPoint _hx_tmp11 = this->_slopePoint;
HXDLIN( 599)						Float _hx_tmp12 = (Slope->y + this->_tileHeight);
HXDLIN( 599)						_hx_tmp11->set_y((_hx_tmp12 - ((Float)(this->_slopePoint->x - Slope->x) / (Float)(int)2)));
            					}
            				}
            			}
            		}
HXLINE( 603)		this->fixSlopePoint(hx::TCast<  ::flixel::tile::FlxTile >::cast(Slope));
HXLINE( 606)		bool _hx_tmp13;
HXDLIN( 606)		bool _hx_tmp14;
HXDLIN( 606)		bool _hx_tmp15;
HXDLIN( 606)		Float _hx_tmp16 = this->_objPoint->x;
HXDLIN( 606)		if ((_hx_tmp16 > (Slope->x + this->_snapping))) {
HXLINE( 606)			Float _hx_tmp17 = this->_objPoint->x;
HXDLIN( 606)			Float _hx_tmp18 = (Slope->x + this->_tileWidth);
HXDLIN( 606)			Float _hx_tmp19 = (_hx_tmp18 + Object->get_width());
HXDLIN( 606)			_hx_tmp15 = (_hx_tmp17 < (_hx_tmp19 + this->_snapping));
            		}
            		else {
HXLINE( 606)			_hx_tmp15 = false;
            		}
HXDLIN( 606)		if (_hx_tmp15) {
HXLINE( 606)			_hx_tmp14 = (this->_objPoint->y >= this->_slopePoint->y);
            		}
            		else {
HXLINE( 606)			_hx_tmp14 = false;
            		}
HXDLIN( 606)		if (_hx_tmp14) {
HXLINE( 606)			Float _hx_tmp20 = this->_objPoint->y;
HXDLIN( 606)			_hx_tmp13 = (_hx_tmp20 <= (Slope->y + this->_tileHeight));
            		}
            		else {
HXLINE( 606)			_hx_tmp13 = false;
            		}
HXDLIN( 606)		if (_hx_tmp13) {
HXLINE( 609)			this->onCollideFloorSlope(Slope,Object);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,solveCollisionSlopeNorthwest,(void))

void FlxTilemapExt_obj::solveCollisionSlopeNortheast( ::flixel::FlxObject Slope, ::flixel::FlxObject Object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_620_solveCollisionSlopeNortheast)
HXLINE( 622)		 ::flixel::math::FlxPoint _hx_tmp = this->_objPoint;
HXDLIN( 622)		_hx_tmp->set_x(::Math_obj::floor((Object->x - this->_snapping)));
HXLINE( 623)		 ::flixel::math::FlxPoint _hx_tmp1 = this->_objPoint;
HXDLIN( 623)		Float Object1 = Object->y;
HXDLIN( 623)		_hx_tmp1->set_y(::Math_obj::floor((Object1 + Object->get_height())));
HXLINE( 627)		this->_slopePoint->set_x(this->_objPoint->x);
HXLINE( 628)		 ::flixel::math::FlxPoint _hx_tmp2 = this->_slopePoint;
HXDLIN( 628)		Float _hx_tmp3 = (Slope->y + this->_tileHeight);
HXDLIN( 628)		_hx_tmp2->set_y((_hx_tmp3 - ((Slope->x - this->_slopePoint->x) + this->_tileWidth)));
HXLINE( 630)		int tileId = hx::TCast<  ::flixel::tile::FlxTile >::cast(Slope)->index;
HXLINE( 631)		if (this->checkThinSteep(tileId)) {
HXLINE( 633)			Float _hx_tmp4 = (this->_slopePoint->x - Slope->x);
HXDLIN( 633)			if ((_hx_tmp4 >= ((Float)this->_tileWidth / (Float)(int)2))) {
HXLINE( 635)				return;
            			}
            			else {
HXLINE( 639)				 ::flixel::math::FlxPoint _hx_tmp5 = this->_slopePoint;
HXDLIN( 639)				Float Slope1 = Slope->y;
HXDLIN( 639)				int _hx_tmp6 = (this->_tileHeight * (int)2);
HXDLIN( 639)				_hx_tmp5->set_y(((Slope1 + (_hx_tmp6 * ((Float)(this->_slopePoint->x - Slope->x) / (Float)this->_tileWidth))) + this->_snapping));
            			}
            		}
            		else {
HXLINE( 642)			if (this->checkThickSteep(tileId)) {
HXLINE( 644)				 ::flixel::math::FlxPoint _hx_tmp7 = this->_slopePoint;
HXDLIN( 644)				Float Slope2 = Slope->y;
HXDLIN( 644)				int _hx_tmp8 = this->_tileHeight;
HXDLIN( 644)				_hx_tmp7->set_y(((Slope2 - (_hx_tmp8 * ((int)1 + ((int)2 * ((Float)(Slope->x - this->_slopePoint->x) / (Float)this->_tileWidth))))) + this->_snapping));
            			}
            			else {
HXLINE( 646)				if (this->checkThickGentle(tileId)) {
HXLINE( 648)					 ::flixel::math::FlxPoint _hx_tmp9 = this->_slopePoint;
HXDLIN( 648)					Float Slope3 = Slope->y;
HXDLIN( 648)					_hx_tmp9->set_y((Slope3 + ((Float)(((this->_tileHeight - Slope->x) + this->_slopePoint->x) - this->_tileWidth) / (Float)(int)2)));
            				}
            				else {
HXLINE( 650)					if (this->checkThinGentle(tileId)) {
HXLINE( 652)						 ::flixel::math::FlxPoint _hx_tmp10 = this->_slopePoint;
HXDLIN( 652)						Float _hx_tmp11 = (Slope->y + this->_tileHeight);
HXDLIN( 652)						_hx_tmp10->set_y((_hx_tmp11 - ((Float)((Slope->x - this->_slopePoint->x) + this->_tileWidth) / (Float)(int)2)));
            					}
            				}
            			}
            		}
HXLINE( 656)		this->fixSlopePoint(hx::TCast<  ::flixel::tile::FlxTile >::cast(Slope));
HXLINE( 659)		bool _hx_tmp12;
HXDLIN( 659)		bool _hx_tmp13;
HXDLIN( 659)		bool _hx_tmp14;
HXDLIN( 659)		Float _hx_tmp15 = this->_objPoint->x;
HXDLIN( 659)		Float Slope4 = Slope->x;
HXDLIN( 659)		Float _hx_tmp16 = (Slope4 - Object->get_width());
HXDLIN( 659)		if ((_hx_tmp15 > (_hx_tmp16 - this->_snapping))) {
HXLINE( 659)			Float _hx_tmp17 = this->_objPoint->x;
HXDLIN( 659)			_hx_tmp14 = (_hx_tmp17 < ((Slope->x + this->_tileWidth) + this->_snapping));
            		}
            		else {
HXLINE( 659)			_hx_tmp14 = false;
            		}
HXDLIN( 659)		if (_hx_tmp14) {
HXLINE( 659)			_hx_tmp13 = (this->_objPoint->y >= this->_slopePoint->y);
            		}
            		else {
HXLINE( 659)			_hx_tmp13 = false;
            		}
HXDLIN( 659)		if (_hx_tmp13) {
HXLINE( 659)			Float _hx_tmp18 = this->_objPoint->y;
HXDLIN( 659)			_hx_tmp12 = (_hx_tmp18 <= (Slope->y + this->_tileHeight));
            		}
            		else {
HXLINE( 659)			_hx_tmp12 = false;
            		}
HXDLIN( 659)		if (_hx_tmp12) {
HXLINE( 662)			this->onCollideFloorSlope(Slope,Object);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,solveCollisionSlopeNortheast,(void))

void FlxTilemapExt_obj::solveCollisionSlopeSouthwest( ::flixel::FlxObject Slope, ::flixel::FlxObject Object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_673_solveCollisionSlopeSouthwest)
HXLINE( 675)		 ::flixel::math::FlxPoint _hx_tmp = this->_objPoint;
HXDLIN( 675)		Float Object1 = Object->x;
HXDLIN( 675)		Float _hx_tmp1 = (Object1 + Object->get_width());
HXDLIN( 675)		_hx_tmp->set_x(::Math_obj::floor((_hx_tmp1 + this->_snapping)));
HXLINE( 676)		 ::flixel::math::FlxPoint _hx_tmp2 = this->_objPoint;
HXDLIN( 676)		_hx_tmp2->set_y(::Math_obj::ceil(Object->y));
HXLINE( 680)		this->_slopePoint->set_x(this->_objPoint->x);
HXLINE( 681)		 ::flixel::math::FlxPoint _hx_tmp3 = this->_slopePoint;
HXDLIN( 681)		Float Slope1 = Slope->y;
HXDLIN( 681)		_hx_tmp3->set_y((Slope1 + (this->_slopePoint->x - Slope->x)));
HXLINE( 683)		int tileId = hx::TCast<  ::flixel::tile::FlxTile >::cast(Slope)->index;
HXLINE( 684)		if (this->checkThinSteep(tileId)) {
HXLINE( 686)			Float _hx_tmp4 = (this->_slopePoint->x - Slope->x);
HXDLIN( 686)			if ((_hx_tmp4 <= ((Float)this->_tileWidth / (Float)(int)2))) {
HXLINE( 688)				return;
            			}
            			else {
HXLINE( 692)				 ::flixel::math::FlxPoint _hx_tmp5 = this->_slopePoint;
HXDLIN( 692)				Float Slope2 = Slope->y;
HXDLIN( 692)				int _hx_tmp6 = this->_tileHeight;
HXDLIN( 692)				_hx_tmp5->set_y(((Slope2 - (_hx_tmp6 * ((int)1 + ((int)2 * ((Float)(Slope->x - this->_slopePoint->x) / (Float)this->_tileWidth))))) - this->_snapping));
            			}
            		}
            		else {
HXLINE( 695)			if (this->checkThickSteep(tileId)) {
HXLINE( 697)				 ::flixel::math::FlxPoint _hx_tmp7 = this->_slopePoint;
HXDLIN( 697)				Float Slope3 = Slope->y;
HXDLIN( 697)				int _hx_tmp8 = (this->_tileHeight * (int)2);
HXDLIN( 697)				_hx_tmp7->set_y(((Slope3 + (_hx_tmp8 * ((Float)(this->_slopePoint->x - Slope->x) / (Float)this->_tileWidth))) - this->_snapping));
            			}
            			else {
HXLINE( 699)				if (this->checkThickGentle(tileId)) {
HXLINE( 701)					 ::flixel::math::FlxPoint _hx_tmp9 = this->_slopePoint;
HXDLIN( 701)					Float _hx_tmp10 = (Slope->y + this->_tileHeight);
HXDLIN( 701)					_hx_tmp9->set_y((_hx_tmp10 - ((Float)((Slope->x - this->_slopePoint->x) + this->_tileWidth) / (Float)(int)2)));
            				}
            				else {
HXLINE( 703)					if (this->checkThinGentle(tileId)) {
HXLINE( 705)						 ::flixel::math::FlxPoint _hx_tmp11 = this->_slopePoint;
HXDLIN( 705)						Float Slope4 = Slope->y;
HXDLIN( 705)						_hx_tmp11->set_y((Slope4 + ((Float)(((this->_tileHeight - Slope->x) + this->_slopePoint->x) - this->_tileWidth) / (Float)(int)2)));
            					}
            				}
            			}
            		}
HXLINE( 709)		this->fixSlopePoint(hx::TCast<  ::flixel::tile::FlxTile >::cast(Slope));
HXLINE( 712)		bool _hx_tmp12;
HXDLIN( 712)		bool _hx_tmp13;
HXDLIN( 712)		bool _hx_tmp14;
HXDLIN( 712)		Float _hx_tmp15 = this->_objPoint->x;
HXDLIN( 712)		if ((_hx_tmp15 > (Slope->x + this->_snapping))) {
HXLINE( 712)			Float _hx_tmp16 = this->_objPoint->x;
HXDLIN( 712)			Float _hx_tmp17 = (Slope->x + this->_tileWidth);
HXDLIN( 712)			Float _hx_tmp18 = (_hx_tmp17 + Object->get_width());
HXDLIN( 712)			_hx_tmp14 = (_hx_tmp16 < (_hx_tmp18 + this->_snapping));
            		}
            		else {
HXLINE( 712)			_hx_tmp14 = false;
            		}
HXDLIN( 712)		if (_hx_tmp14) {
HXLINE( 712)			_hx_tmp13 = (this->_objPoint->y <= this->_slopePoint->y);
            		}
            		else {
HXLINE( 712)			_hx_tmp13 = false;
            		}
HXDLIN( 712)		if (_hx_tmp13) {
HXLINE( 712)			_hx_tmp12 = (this->_objPoint->y >= Slope->y);
            		}
            		else {
HXLINE( 712)			_hx_tmp12 = false;
            		}
HXDLIN( 712)		if (_hx_tmp12) {
HXLINE( 715)			this->onCollideCeilSlope(Slope,Object);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,solveCollisionSlopeSouthwest,(void))

void FlxTilemapExt_obj::solveCollisionSlopeSoutheast( ::flixel::FlxObject Slope, ::flixel::FlxObject Object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_726_solveCollisionSlopeSoutheast)
HXLINE( 728)		 ::flixel::math::FlxPoint _hx_tmp = this->_objPoint;
HXDLIN( 728)		_hx_tmp->set_x(::Math_obj::floor((Object->x - this->_snapping)));
HXLINE( 729)		 ::flixel::math::FlxPoint _hx_tmp1 = this->_objPoint;
HXDLIN( 729)		_hx_tmp1->set_y(::Math_obj::ceil(Object->y));
HXLINE( 733)		this->_slopePoint->set_x(this->_objPoint->x);
HXLINE( 734)		 ::flixel::math::FlxPoint _hx_tmp2 = this->_slopePoint;
HXDLIN( 734)		Float Slope1 = Slope->y;
HXDLIN( 734)		_hx_tmp2->set_y((Slope1 + ((Slope->x - this->_slopePoint->x) + this->_tileWidth)));
HXLINE( 736)		int tileId = hx::TCast<  ::flixel::tile::FlxTile >::cast(Slope)->index;
HXLINE( 737)		if (this->checkThinSteep(tileId)) {
HXLINE( 739)			Float _hx_tmp3 = (this->_slopePoint->x - Slope->x);
HXDLIN( 739)			if ((_hx_tmp3 >= ((Float)this->_tileWidth / (Float)(int)2))) {
HXLINE( 741)				return;
            			}
            			else {
HXLINE( 745)				 ::flixel::math::FlxPoint _hx_tmp4 = this->_slopePoint;
HXDLIN( 745)				Float Slope2 = Slope->y;
HXDLIN( 745)				int _hx_tmp5 = this->_tileHeight;
HXDLIN( 745)				_hx_tmp4->set_y(((Slope2 + (_hx_tmp5 * ((int)1 - ((int)2 * ((Float)(this->_slopePoint->x - Slope->x) / (Float)this->_tileWidth))))) - this->_snapping));
            			}
            		}
            		else {
HXLINE( 748)			if (this->checkThickSteep(tileId)) {
HXLINE( 750)				 ::flixel::math::FlxPoint _hx_tmp6 = this->_slopePoint;
HXDLIN( 750)				Float Slope3 = Slope->y;
HXDLIN( 750)				int _hx_tmp7 = this->_tileHeight;
HXDLIN( 750)				_hx_tmp6->set_y(((Slope3 + (_hx_tmp7 * ((int)2 - ((Float)((int)2 * (this->_slopePoint->x - Slope->x)) / (Float)this->_tileWidth)))) - this->_snapping));
            			}
            			else {
HXLINE( 752)				if (this->checkThickGentle(tileId)) {
HXLINE( 754)					 ::flixel::math::FlxPoint _hx_tmp8 = this->_slopePoint;
HXDLIN( 754)					Float _hx_tmp9 = (Slope->y + this->_tileHeight);
HXDLIN( 754)					_hx_tmp8->set_y((_hx_tmp9 - ((Float)(this->_slopePoint->x - Slope->x) / (Float)(int)2)));
            				}
            				else {
HXLINE( 756)					if (this->checkThinGentle(tileId)) {
HXLINE( 758)						 ::flixel::math::FlxPoint _hx_tmp10 = this->_slopePoint;
HXDLIN( 758)						Float Slope4 = Slope->y;
HXDLIN( 758)						_hx_tmp10->set_y((Slope4 + ((Float)((this->_tileHeight - this->_slopePoint->x) + Slope->x) / (Float)(int)2)));
            					}
            				}
            			}
            		}
HXLINE( 762)		this->fixSlopePoint(hx::TCast<  ::flixel::tile::FlxTile >::cast(Slope));
HXLINE( 765)		bool _hx_tmp11;
HXDLIN( 765)		bool _hx_tmp12;
HXDLIN( 765)		bool _hx_tmp13;
HXDLIN( 765)		Float _hx_tmp14 = this->_objPoint->x;
HXDLIN( 765)		Float Slope5 = Slope->x;
HXDLIN( 765)		Float _hx_tmp15 = (Slope5 - Object->get_width());
HXDLIN( 765)		if ((_hx_tmp14 > (_hx_tmp15 - this->_snapping))) {
HXLINE( 765)			Float _hx_tmp16 = this->_objPoint->x;
HXDLIN( 765)			_hx_tmp13 = (_hx_tmp16 < ((Slope->x + this->_tileWidth) + this->_snapping));
            		}
            		else {
HXLINE( 765)			_hx_tmp13 = false;
            		}
HXDLIN( 765)		if (_hx_tmp13) {
HXLINE( 765)			_hx_tmp12 = (this->_objPoint->y <= this->_slopePoint->y);
            		}
            		else {
HXLINE( 765)			_hx_tmp12 = false;
            		}
HXDLIN( 765)		if (_hx_tmp12) {
HXLINE( 765)			_hx_tmp11 = (this->_objPoint->y >= Slope->y);
            		}
            		else {
HXLINE( 765)			_hx_tmp11 = false;
            		}
HXDLIN( 765)		if (_hx_tmp11) {
HXLINE( 768)			this->onCollideCeilSlope(Slope,Object);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,solveCollisionSlopeSoutheast,(void))

void FlxTilemapExt_obj::setSlopeProperties(){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_777_setSlopeProperties)
HXLINE( 778)		{
HXLINE( 778)			int _g = (int)0;
HXDLIN( 778)			::Array< int > _g1 = this->_slopeNorthwest;
HXDLIN( 778)			while((_g < _g1->length)){
HXLINE( 778)				int tile = _g1->__get(_g);
HXDLIN( 778)				_g = (_g + (int)1);
HXLINE( 780)				this->setTileProperties(tile,(int)4112,this->solveCollisionSlopeNorthwest_dyn(),null(),null());
            			}
            		}
HXLINE( 782)		{
HXLINE( 782)			int _g2 = (int)0;
HXDLIN( 782)			::Array< int > _g11 = this->_slopeNortheast;
HXDLIN( 782)			while((_g2 < _g11->length)){
HXLINE( 782)				int tile1 = _g11->__get(_g2);
HXDLIN( 782)				_g2 = (_g2 + (int)1);
HXLINE( 784)				this->setTileProperties(tile1,(int)4097,this->solveCollisionSlopeNortheast_dyn(),null(),null());
            			}
            		}
HXLINE( 786)		{
HXLINE( 786)			int _g3 = (int)0;
HXDLIN( 786)			::Array< int > _g12 = this->_slopeSouthwest;
HXDLIN( 786)			while((_g3 < _g12->length)){
HXLINE( 786)				int tile2 = _g12->__get(_g3);
HXDLIN( 786)				_g3 = (_g3 + (int)1);
HXLINE( 788)				this->setTileProperties(tile2,(int)272,this->solveCollisionSlopeSouthwest_dyn(),null(),null());
            			}
            		}
HXLINE( 790)		{
HXLINE( 790)			int _g4 = (int)0;
HXDLIN( 790)			::Array< int > _g13 = this->_slopeSoutheast;
HXDLIN( 790)			while((_g4 < _g13->length)){
HXLINE( 790)				int tile3 = _g13->__get(_g4);
HXDLIN( 790)				_g4 = (_g4 + (int)1);
HXLINE( 792)				this->setTileProperties(tile3,(int)257,this->solveCollisionSlopeSoutheast_dyn(),null(),null());
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTilemapExt_obj,setSlopeProperties,(void))

bool FlxTilemapExt_obj::checkArrays(int TileIndex){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_804_checkArrays)
HXDLIN( 804)		bool _hx_tmp;
HXDLIN( 804)		bool _hx_tmp1;
HXDLIN( 804)		if ((this->_slopeNorthwest->indexOf(TileIndex,null()) < (int)0)) {
HXDLIN( 804)			_hx_tmp1 = (this->_slopeNortheast->indexOf(TileIndex,null()) >= (int)0);
            		}
            		else {
HXDLIN( 804)			_hx_tmp1 = true;
            		}
HXDLIN( 804)		if (!(_hx_tmp1)) {
HXDLIN( 804)			_hx_tmp = (this->_slopeSouthwest->indexOf(TileIndex,null()) >= (int)0);
            		}
            		else {
HXDLIN( 804)			_hx_tmp = true;
            		}
HXDLIN( 804)		if (!(_hx_tmp)) {
HXDLIN( 804)			return (this->_slopeSoutheast->indexOf(TileIndex,null()) >= (int)0);
            		}
            		else {
HXDLIN( 804)			return true;
            		}
HXDLIN( 804)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,checkArrays,return )

 ::flixel::graphics::frames::FlxFramesCollection FlxTilemapExt_obj::set_frames( ::flixel::graphics::frames::FlxFramesCollection value){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_808_set_frames)
HXLINE( 809)		this->super::set_frames(value);
HXLINE( 811)		bool _hx_tmp;
HXDLIN( 811)		bool _hx_tmp1;
HXDLIN( 811)		if (hx::IsNotNull( value )) {
HXLINE( 811)			_hx_tmp1 = hx::IsNotNull( this->_specialTiles );
            		}
            		else {
HXLINE( 811)			_hx_tmp1 = false;
            		}
HXDLIN( 811)		if (_hx_tmp1) {
HXLINE( 811)			_hx_tmp = (this->_specialTiles->length > (int)0);
            		}
            		else {
HXLINE( 811)			_hx_tmp = false;
            		}
HXDLIN( 811)		if (_hx_tmp) {
HXLINE( 813)			int _g = (int)0;
HXDLIN( 813)			::Array< ::Dynamic> _g1 = this->_specialTiles;
HXDLIN( 813)			while((_g < _g1->length)){
HXLINE( 813)				 ::flixel::addons::tile::FlxTileSpecial tile = _g1->__get(_g).StaticCast<  ::flixel::addons::tile::FlxTileSpecial >();
HXDLIN( 813)				_g = (_g + (int)1);
HXLINE( 815)				if (hx::IsNotNull( tile )) {
HXLINE( 817)					tile->set_frames(this->frames);
            				}
            			}
            		}
HXLINE( 822)		return value;
            	}



hx::ObjectPtr< FlxTilemapExt_obj > FlxTilemapExt_obj::__new() {
	hx::ObjectPtr< FlxTilemapExt_obj > __this = new FlxTilemapExt_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< FlxTilemapExt_obj > FlxTilemapExt_obj::__alloc(hx::Ctx *_hx_ctx) {
	FlxTilemapExt_obj *__this = (FlxTilemapExt_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(FlxTilemapExt_obj), true, "flixel.addons.tile.FlxTilemapExt"));
	*(void **)__this = FlxTilemapExt_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

FlxTilemapExt_obj::FlxTilemapExt_obj()
{
}

void FlxTilemapExt_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxTilemapExt);
	HX_MARK_MEMBER_NAME(_snapping,"_snapping");
	HX_MARK_MEMBER_NAME(_slopePoint,"_slopePoint");
	HX_MARK_MEMBER_NAME(_objPoint,"_objPoint");
	HX_MARK_MEMBER_NAME(_slopeNorthwest,"_slopeNorthwest");
	HX_MARK_MEMBER_NAME(_slopeNortheast,"_slopeNortheast");
	HX_MARK_MEMBER_NAME(_slopeSouthwest,"_slopeSouthwest");
	HX_MARK_MEMBER_NAME(_slopeSoutheast,"_slopeSoutheast");
	HX_MARK_MEMBER_NAME(_slopeThickGentle,"_slopeThickGentle");
	HX_MARK_MEMBER_NAME(_slopeThinGentle,"_slopeThinGentle");
	HX_MARK_MEMBER_NAME(_slopeThickSteep,"_slopeThickSteep");
	HX_MARK_MEMBER_NAME(_slopeThinSteep,"_slopeThinSteep");
	HX_MARK_MEMBER_NAME(_specialTiles,"_specialTiles");
	 ::flixel::tile::FlxTilemap_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxTilemapExt_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_snapping,"_snapping");
	HX_VISIT_MEMBER_NAME(_slopePoint,"_slopePoint");
	HX_VISIT_MEMBER_NAME(_objPoint,"_objPoint");
	HX_VISIT_MEMBER_NAME(_slopeNorthwest,"_slopeNorthwest");
	HX_VISIT_MEMBER_NAME(_slopeNortheast,"_slopeNortheast");
	HX_VISIT_MEMBER_NAME(_slopeSouthwest,"_slopeSouthwest");
	HX_VISIT_MEMBER_NAME(_slopeSoutheast,"_slopeSoutheast");
	HX_VISIT_MEMBER_NAME(_slopeThickGentle,"_slopeThickGentle");
	HX_VISIT_MEMBER_NAME(_slopeThinGentle,"_slopeThinGentle");
	HX_VISIT_MEMBER_NAME(_slopeThickSteep,"_slopeThickSteep");
	HX_VISIT_MEMBER_NAME(_slopeThinSteep,"_slopeThinSteep");
	HX_VISIT_MEMBER_NAME(_specialTiles,"_specialTiles");
	 ::flixel::tile::FlxTilemap_obj::__Visit(HX_VISIT_ARG);
}

hx::Val FlxTilemapExt_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"setSteep") ) { return hx::Val( setSteep_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_snapping") ) { return hx::Val( _snapping ); }
		if (HX_FIELD_EQ(inName,"_objPoint") ) { return hx::Val( _objPoint ); }
		if (HX_FIELD_EQ(inName,"setSlopes") ) { return hx::Val( setSlopes_dyn() ); }
		if (HX_FIELD_EQ(inName,"setGentle") ) { return hx::Val( setGentle_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"set_frames") ) { return hx::Val( set_frames_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_slopePoint") ) { return hx::Val( _slopePoint ); }
		if (HX_FIELD_EQ(inName,"drawTilemap") ) { return hx::Val( drawTilemap_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkArrays") ) { return hx::Val( checkArrays_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_specialTiles") ) { return hx::Val( _specialTiles ); }
		if (HX_FIELD_EQ(inName,"fixSlopePoint") ) { return hx::Val( fixSlopePoint_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"checkThinSteep") ) { return hx::Val( checkThinSteep_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_slopeNorthwest") ) { return hx::Val( _slopeNorthwest ); }
		if (HX_FIELD_EQ(inName,"_slopeNortheast") ) { return hx::Val( _slopeNortheast ); }
		if (HX_FIELD_EQ(inName,"_slopeSouthwest") ) { return hx::Val( _slopeSouthwest ); }
		if (HX_FIELD_EQ(inName,"_slopeSoutheast") ) { return hx::Val( _slopeSoutheast ); }
		if (HX_FIELD_EQ(inName,"_slopeThinSteep") ) { return hx::Val( _slopeThinSteep ); }
		if (HX_FIELD_EQ(inName,"setSpecialTiles") ) { return hx::Val( setSpecialTiles_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkThinGentle") ) { return hx::Val( checkThinGentle_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkThickSteep") ) { return hx::Val( checkThickSteep_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"_slopeThinGentle") ) { return hx::Val( _slopeThinGentle ); }
		if (HX_FIELD_EQ(inName,"_slopeThickSteep") ) { return hx::Val( _slopeThickSteep ); }
		if (HX_FIELD_EQ(inName,"checkThickGentle") ) { return hx::Val( checkThickGentle_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"_slopeThickGentle") ) { return hx::Val( _slopeThickGentle ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"onCollideCeilSlope") ) { return hx::Val( onCollideCeilSlope_dyn() ); }
		if (HX_FIELD_EQ(inName,"setSlopeProperties") ) { return hx::Val( setSlopeProperties_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"onCollideFloorSlope") ) { return hx::Val( onCollideFloorSlope_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"overlapsWithCallback") ) { return hx::Val( overlapsWithCallback_dyn() ); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"solveCollisionSlopeNorthwest") ) { return hx::Val( solveCollisionSlopeNorthwest_dyn() ); }
		if (HX_FIELD_EQ(inName,"solveCollisionSlopeNortheast") ) { return hx::Val( solveCollisionSlopeNortheast_dyn() ); }
		if (HX_FIELD_EQ(inName,"solveCollisionSlopeSouthwest") ) { return hx::Val( solveCollisionSlopeSouthwest_dyn() ); }
		if (HX_FIELD_EQ(inName,"solveCollisionSlopeSoutheast") ) { return hx::Val( solveCollisionSlopeSoutheast_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val FlxTilemapExt_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"_snapping") ) { _snapping=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_objPoint") ) { _objPoint=inValue.Cast<  ::flixel::math::FlxPoint >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_slopePoint") ) { _slopePoint=inValue.Cast<  ::flixel::math::FlxPoint >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_specialTiles") ) { _specialTiles=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_slopeNorthwest") ) { _slopeNorthwest=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_slopeNortheast") ) { _slopeNortheast=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_slopeSouthwest") ) { _slopeSouthwest=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_slopeSoutheast") ) { _slopeSoutheast=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_slopeThinSteep") ) { _slopeThinSteep=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"_slopeThinGentle") ) { _slopeThinGentle=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_slopeThickSteep") ) { _slopeThickSteep=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"_slopeThickGentle") ) { _slopeThickGentle=inValue.Cast< ::Array< int > >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxTilemapExt_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("_snapping","\x1b","\x2d","\x4f","\x67"));
	outFields->push(HX_HCSTRING("_slopePoint","\x44","\xf8","\xe1","\xeb"));
	outFields->push(HX_HCSTRING("_objPoint","\x38","\x4c","\x3e","\xbb"));
	outFields->push(HX_HCSTRING("_slopeNorthwest","\x68","\x65","\x26","\x14"));
	outFields->push(HX_HCSTRING("_slopeNortheast","\x36","\x85","\x3d","\x08"));
	outFields->push(HX_HCSTRING("_slopeSouthwest","\xb0","\xd6","\x9d","\xaf"));
	outFields->push(HX_HCSTRING("_slopeSoutheast","\x7e","\xf6","\xb4","\xa3"));
	outFields->push(HX_HCSTRING("_slopeThickGentle","\x8e","\xe6","\x40","\x0b"));
	outFields->push(HX_HCSTRING("_slopeThinGentle","\x22","\xc8","\x46","\xc5"));
	outFields->push(HX_HCSTRING("_slopeThickSteep","\xfe","\x19","\x69","\x07"));
	outFields->push(HX_HCSTRING("_slopeThinSteep","\xea","\x86","\xa2","\x7f"));
	outFields->push(HX_HCSTRING("_specialTiles","\x6b","\xd7","\xb8","\x46"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo FlxTilemapExt_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(FlxTilemapExt_obj,_snapping),HX_HCSTRING("_snapping","\x1b","\x2d","\x4f","\x67")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(int)offsetof(FlxTilemapExt_obj,_slopePoint),HX_HCSTRING("_slopePoint","\x44","\xf8","\xe1","\xeb")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(int)offsetof(FlxTilemapExt_obj,_objPoint),HX_HCSTRING("_objPoint","\x38","\x4c","\x3e","\xbb")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(FlxTilemapExt_obj,_slopeNorthwest),HX_HCSTRING("_slopeNorthwest","\x68","\x65","\x26","\x14")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(FlxTilemapExt_obj,_slopeNortheast),HX_HCSTRING("_slopeNortheast","\x36","\x85","\x3d","\x08")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(FlxTilemapExt_obj,_slopeSouthwest),HX_HCSTRING("_slopeSouthwest","\xb0","\xd6","\x9d","\xaf")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(FlxTilemapExt_obj,_slopeSoutheast),HX_HCSTRING("_slopeSoutheast","\x7e","\xf6","\xb4","\xa3")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(FlxTilemapExt_obj,_slopeThickGentle),HX_HCSTRING("_slopeThickGentle","\x8e","\xe6","\x40","\x0b")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(FlxTilemapExt_obj,_slopeThinGentle),HX_HCSTRING("_slopeThinGentle","\x22","\xc8","\x46","\xc5")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(FlxTilemapExt_obj,_slopeThickSteep),HX_HCSTRING("_slopeThickSteep","\xfe","\x19","\x69","\x07")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(FlxTilemapExt_obj,_slopeThinSteep),HX_HCSTRING("_slopeThinSteep","\xea","\x86","\xa2","\x7f")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(FlxTilemapExt_obj,_specialTiles),HX_HCSTRING("_specialTiles","\x6b","\xd7","\xb8","\x46")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *FlxTilemapExt_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxTilemapExt_obj_sMemberFields[] = {
	HX_HCSTRING("_snapping","\x1b","\x2d","\x4f","\x67"),
	HX_HCSTRING("_slopePoint","\x44","\xf8","\xe1","\xeb"),
	HX_HCSTRING("_objPoint","\x38","\x4c","\x3e","\xbb"),
	HX_HCSTRING("_slopeNorthwest","\x68","\x65","\x26","\x14"),
	HX_HCSTRING("_slopeNortheast","\x36","\x85","\x3d","\x08"),
	HX_HCSTRING("_slopeSouthwest","\xb0","\xd6","\x9d","\xaf"),
	HX_HCSTRING("_slopeSoutheast","\x7e","\xf6","\xb4","\xa3"),
	HX_HCSTRING("_slopeThickGentle","\x8e","\xe6","\x40","\x0b"),
	HX_HCSTRING("_slopeThinGentle","\x22","\xc8","\x46","\xc5"),
	HX_HCSTRING("_slopeThickSteep","\xfe","\x19","\x69","\x07"),
	HX_HCSTRING("_slopeThinSteep","\xea","\x86","\xa2","\x7f"),
	HX_HCSTRING("_specialTiles","\x6b","\xd7","\xb8","\x46"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("drawTilemap","\x8a","\x34","\xd7","\x8e"),
	HX_HCSTRING("setSpecialTiles","\x4e","\x17","\x00","\x83"),
	HX_HCSTRING("overlapsWithCallback","\x17","\xc3","\x72","\xa8"),
	HX_HCSTRING("setSlopes","\x2a","\x9e","\xac","\xd3"),
	HX_HCSTRING("setGentle","\x9f","\x12","\xf0","\xfe"),
	HX_HCSTRING("setSteep","\x0d","\xdb","\x42","\x92"),
	HX_HCSTRING("checkThickGentle","\xb2","\xd7","\xc5","\x10"),
	HX_HCSTRING("checkThinGentle","\x7e","\x47","\xf1","\x74"),
	HX_HCSTRING("checkThickSteep","\x5a","\x99","\x13","\xb7"),
	HX_HCSTRING("checkThinSteep","\x0e","\x27","\x64","\x59"),
	HX_HCSTRING("fixSlopePoint","\x5a","\x6d","\x81","\x3a"),
	HX_HCSTRING("onCollideFloorSlope","\xbe","\x60","\x9b","\xe6"),
	HX_HCSTRING("onCollideCeilSlope","\xc7","\x17","\xd1","\xc7"),
	HX_HCSTRING("solveCollisionSlopeNorthwest","\x1c","\xb5","\xa5","\x09"),
	HX_HCSTRING("solveCollisionSlopeNortheast","\xea","\xd4","\xbc","\xfd"),
	HX_HCSTRING("solveCollisionSlopeSouthwest","\x64","\x26","\x1d","\xa5"),
	HX_HCSTRING("solveCollisionSlopeSoutheast","\x32","\x46","\x34","\x99"),
	HX_HCSTRING("setSlopeProperties","\x7c","\x73","\x53","\xcf"),
	HX_HCSTRING("checkArrays","\xa2","\x4b","\x02","\x9a"),
	HX_HCSTRING("set_frames","\xe3","\xbd","\x8a","\xa0"),
	::String(null()) };

static void FlxTilemapExt_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxTilemapExt_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxTilemapExt_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxTilemapExt_obj::__mClass,"__mClass");
};

#endif

hx::Class FlxTilemapExt_obj::__mClass;

void FlxTilemapExt_obj::__register()
{
	hx::Object *dummy = new FlxTilemapExt_obj;
	FlxTilemapExt_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.addons.tile.FlxTilemapExt","\xce","\x82","\x6d","\xe6");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = FlxTilemapExt_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FlxTilemapExt_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FlxTilemapExt_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxTilemapExt_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxTilemapExt_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxTilemapExt_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace addons
} // end namespace tile
